{"ast":null,"code":"import _objectSpread from\"/Users/jamescunningham/Desktop/safepath-sf/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{getRouteSefetyScore}from\"./SafetyDataService\";const GRAPHHOPPER_API_KEY=process.env.REACT_APP_GRAPHHOPPER_API_KEY||\"\";const GEOCODING_URL=\"https://graphhopper.com/api/1/geocode\";const ROUTING_URL=\"https://graphhopper.com/api/1/route\";/**\n * Convert address to coordinates using GraphHopper Geocoding API\n */export async function geocodeAddress(address){try{const response=await fetch(\"\".concat(GEOCODING_URL,\"?q=\").concat(encodeURIComponent(address),\"&key=\").concat(GRAPHHOPPER_API_KEY));if(!response.ok){throw new Error(\"Geocoding failed: \".concat(response.statusText));}const data=await response.json();if(data.hits&&data.hits.length>0){return data.hits[0].point;}return null;}catch(error){console.error(\"Geocoding error:\",error);return null;}}/**\n * Calculate routes between two points using GraphHopper Routing API\n */export async function calculateRoutes(origin,destination){try{// Step 1: Geocode origin and destination\nconst originCoords=await geocodeAddress(origin);const destCoords=await geocodeAddress(destination);if(!originCoords||!destCoords){throw new Error(\"Could not geocode addresses\");}// Step 2: Get multiple route alternatives\n// Build URL with multiple 'point' parameters\nconst params=new URLSearchParams({vehicle:\"foot\",// walking routes\nlocale:\"en\",points_encoded:\"false\",algorithm:\"alternative_route\",\"alternative_route.max_paths\":\"3\",key:GRAPHHOPPER_API_KEY});// Add points manually (URLSearchParams doesn't support duplicate keys in object literal)\nparams.append(\"point\",\"\".concat(originCoords.lat,\",\").concat(originCoords.lng));params.append(\"point\",\"\".concat(destCoords.lat,\",\").concat(destCoords.lng));const response=await fetch(\"\".concat(ROUTING_URL,\"?\").concat(params.toString()));if(!response.ok){throw new Error(\"Routing failed: \".concat(response.statusText));}const data=await response.json();if(!data.paths||data.paths.length===0){throw new Error(\"No routes found\");}// Step 3: Convert GraphHopper routes to our Route format with real safety data\nconst convertedRoutes=await Promise.all(data.paths.map(async(path,index)=>{const distanceInMiles=(path.distance/1609.34).toFixed(1);const timeInMinutes=Math.round(path.time/1000/60);// Convert coordinates from [lng, lat] to {lat, lng}\nconst coordinates=path.points.coordinates.map(coord=>({lat:coord[1],lng:coord[0]}));// Get real-time safety data from SF APIs\nconst safetyMetrics=await getRouteSefetyScore(coordinates);// Generate route name based on safety scores\nconst routeName=safetyMetrics.safetyScore>=90?\"Safest Route\":safetyMetrics.safetyScore>=75?\"Balanced Route\":\"Fastest Route\";// Route colors based on safety\nconst color=safetyMetrics.safetyScore>=90?\"#10b981\":safetyMetrics.safetyScore>=75?\"#3b82f6\":\"#f59e0b\";// Generate waypoints with incident information\nconst numWaypoints=Math.min(3,safetyMetrics.incidents.length);const waypoints=safetyMetrics.incidents.slice(0,numWaypoints).map((incident,i)=>({name:incident.description.substring(0,30),type:incident.type===\"crime\"?\"Crime incident\":incident.type===\"encampment\"?\"Encampment\":\"Safety concern\",safe:incident.severity!==\"high\"}));// Add additional waypoints if needed\nwhile(waypoints.length<3){waypoints.push({name:\"Checkpoint \".concat(waypoints.length+1),type:\"Clear area\",safe:true});}return{id:index+1,name:routeName,distance:\"\".concat(distanceInMiles,\" mi\"),time:\"\".concat(timeInMinutes,\" min\"),safetyScore:safetyMetrics.safetyScore,crimeScore:safetyMetrics.crimeScore,timeScore:100-timeInMinutes*2,// Lower time = higher score\nsocialScore:safetyMetrics.socialScore,pedestrianScore:safetyMetrics.pedestrianScore,coordinates:coordinates,waypoints:waypoints,color:color};}));// Sort routes by safety score\nconvertedRoutes.sort((a,b)=>b.safetyScore-a.safetyScore);// Ensure we always have at least 3 route variants\nconst routes=[];const routeNames=[\"Safest Route\",\"Balanced Route\",\"Fastest Route\"];const colors=[\"#10b981\",\"#3b82f6\",\"#f59e0b\"];for(let i=0;i<3;i++){if(convertedRoutes[i]){// Use the converted route if it exists\nroutes.push(_objectSpread(_objectSpread({},convertedRoutes[i]),{},{id:i+1,name:routeNames[i],color:colors[i]}));}else if(convertedRoutes[0]){// Create a variant of the first route with adjusted parameters if we don't have enough routes\nconst baseRoute=convertedRoutes[0];const adjustmentFactor=1-i*0.1;// Slightly adjust scores for variety\nroutes.push(_objectSpread(_objectSpread({},baseRoute),{},{id:i+1,name:routeNames[i],safetyScore:Math.round(baseRoute.safetyScore*adjustmentFactor),crimeScore:Math.round(baseRoute.crimeScore*adjustmentFactor),socialScore:Math.round(baseRoute.socialScore*adjustmentFactor),pedestrianScore:Math.round(baseRoute.pedestrianScore*adjustmentFactor),color:colors[i]}));}}return{routes,originCoords,destCoords};}catch(error){console.error(\"GraphHopper routing error:\",error);return null;}}/**\n * Check if GraphHopper API key is configured\n */export function isGraphHopperConfigured(){return GRAPHHOPPER_API_KEY.length>0;}","map":{"version":3,"names":["getRouteSefetyScore","GRAPHHOPPER_API_KEY","process","env","REACT_APP_GRAPHHOPPER_API_KEY","GEOCODING_URL","ROUTING_URL","geocodeAddress","address","response","fetch","concat","encodeURIComponent","ok","Error","statusText","data","json","hits","length","point","error","console","calculateRoutes","origin","destination","originCoords","destCoords","params","URLSearchParams","vehicle","locale","points_encoded","algorithm","key","append","lat","lng","toString","paths","convertedRoutes","Promise","all","map","path","index","distanceInMiles","distance","toFixed","timeInMinutes","Math","round","time","coordinates","points","coord","safetyMetrics","routeName","safetyScore","color","numWaypoints","min","incidents","waypoints","slice","incident","i","name","description","substring","type","safe","severity","push","id","crimeScore","timeScore","socialScore","pedestrianScore","sort","a","b","routes","routeNames","colors","_objectSpread","baseRoute","adjustmentFactor","isGraphHopperConfigured"],"sources":["/Users/jamescunningham/Desktop/safepath-sf/src/services/graphhopper.ts"],"sourcesContent":["import type { Route } from \"@/components/safe-path-app\"\nimport { getRouteSefetyScore } from \"./SafetyDataService\"\n\nconst GRAPHHOPPER_API_KEY = process.env.REACT_APP_GRAPHHOPPER_API_KEY || \"\"\nconst GEOCODING_URL = \"https://graphhopper.com/api/1/geocode\"\nconst ROUTING_URL = \"https://graphhopper.com/api/1/route\"\n\ninterface GeocodingResult {\n  hits: Array<{\n    point: {\n      lat: number\n      lng: number\n    }\n    name: string\n  }>\n}\n\ninterface GraphHopperRoute {\n  distance: number // in meters\n  time: number // in milliseconds\n  points: {\n    coordinates: Array<[number, number]> // [lng, lat]\n  }\n}\n\ninterface RoutingResult {\n  paths: GraphHopperRoute[]\n}\n\n/**\n * Convert address to coordinates using GraphHopper Geocoding API\n */\nexport async function geocodeAddress(address: string): Promise<{ lat: number; lng: number } | null> {\n  try {\n    const response = await fetch(`${GEOCODING_URL}?q=${encodeURIComponent(address)}&key=${GRAPHHOPPER_API_KEY}`)\n\n    if (!response.ok) {\n      throw new Error(`Geocoding failed: ${response.statusText}`)\n    }\n\n    const data: GeocodingResult = await response.json()\n\n    if (data.hits && data.hits.length > 0) {\n      return data.hits[0].point\n    }\n\n    return null\n  } catch (error) {\n    console.error(\"Geocoding error:\", error)\n    return null\n  }\n}\n\n/**\n * Calculate routes between two points using GraphHopper Routing API\n */\nexport async function calculateRoutes(\n  origin: string,\n  destination: string\n): Promise<{ routes: Route[]; originCoords: { lat: number; lng: number }; destCoords: { lat: number; lng: number } } | null> {\n  try {\n    // Step 1: Geocode origin and destination\n    const originCoords = await geocodeAddress(origin)\n    const destCoords = await geocodeAddress(destination)\n\n    if (!originCoords || !destCoords) {\n      throw new Error(\"Could not geocode addresses\")\n    }\n\n    // Step 2: Get multiple route alternatives\n    // Build URL with multiple 'point' parameters\n    const params = new URLSearchParams({\n      vehicle: \"foot\", // walking routes\n      locale: \"en\",\n      points_encoded: \"false\",\n      algorithm: \"alternative_route\",\n      \"alternative_route.max_paths\": \"3\",\n      key: GRAPHHOPPER_API_KEY,\n    })\n\n    // Add points manually (URLSearchParams doesn't support duplicate keys in object literal)\n    params.append(\"point\", `${originCoords.lat},${originCoords.lng}`)\n    params.append(\"point\", `${destCoords.lat},${destCoords.lng}`)\n\n    const response = await fetch(`${ROUTING_URL}?${params.toString()}`)\n\n    if (!response.ok) {\n      throw new Error(`Routing failed: ${response.statusText}`)\n    }\n\n    const data: RoutingResult = await response.json()\n\n    if (!data.paths || data.paths.length === 0) {\n      throw new Error(\"No routes found\")\n    }\n\n    // Step 3: Convert GraphHopper routes to our Route format with real safety data\n    const convertedRoutes: Route[] = await Promise.all(\n      data.paths.map(async (path, index) => {\n        const distanceInMiles = (path.distance / 1609.34).toFixed(1)\n        const timeInMinutes = Math.round(path.time / 1000 / 60)\n\n        // Convert coordinates from [lng, lat] to {lat, lng}\n        const coordinates = path.points.coordinates.map((coord) => ({\n          lat: coord[1],\n          lng: coord[0],\n        }))\n\n        // Get real-time safety data from SF APIs\n        const safetyMetrics = await getRouteSefetyScore(coordinates)\n\n        // Generate route name based on safety scores\n        const routeName =\n          safetyMetrics.safetyScore >= 90\n            ? \"Safest Route\"\n            : safetyMetrics.safetyScore >= 75\n            ? \"Balanced Route\"\n            : \"Fastest Route\"\n\n        // Route colors based on safety\n        const color =\n          safetyMetrics.safetyScore >= 90\n            ? \"#10b981\"\n            : safetyMetrics.safetyScore >= 75\n            ? \"#3b82f6\"\n            : \"#f59e0b\"\n\n        // Generate waypoints with incident information\n        const numWaypoints = Math.min(3, safetyMetrics.incidents.length)\n        const waypoints = safetyMetrics.incidents.slice(0, numWaypoints).map((incident, i) => ({\n          name: incident.description.substring(0, 30),\n          type: incident.type === \"crime\" ? \"Crime incident\" : incident.type === \"encampment\" ? \"Encampment\" : \"Safety concern\",\n          safe: incident.severity !== \"high\",\n        }))\n\n        // Add additional waypoints if needed\n        while (waypoints.length < 3) {\n          waypoints.push({\n            name: `Checkpoint ${waypoints.length + 1}`,\n            type: \"Clear area\",\n            safe: true,\n          })\n        }\n\n        return {\n          id: index + 1,\n          name: routeName,\n          distance: `${distanceInMiles} mi`,\n          time: `${timeInMinutes} min`,\n          safetyScore: safetyMetrics.safetyScore,\n          crimeScore: safetyMetrics.crimeScore,\n          timeScore: 100 - (timeInMinutes * 2), // Lower time = higher score\n          socialScore: safetyMetrics.socialScore,\n          pedestrianScore: safetyMetrics.pedestrianScore,\n          coordinates: coordinates,\n          waypoints: waypoints,\n          color: color,\n        }\n      })\n    )\n\n    // Sort routes by safety score\n    convertedRoutes.sort((a, b) => b.safetyScore - a.safetyScore)\n\n    // Ensure we always have at least 3 route variants\n    const routes: Route[] = []\n    const routeNames = [\"Safest Route\", \"Balanced Route\", \"Fastest Route\"]\n    const colors = [\"#10b981\", \"#3b82f6\", \"#f59e0b\"]\n\n    for (let i = 0; i < 3; i++) {\n      if (convertedRoutes[i]) {\n        // Use the converted route if it exists\n        routes.push({\n          ...convertedRoutes[i],\n          id: i + 1,\n          name: routeNames[i],\n          color: colors[i],\n        })\n      } else if (convertedRoutes[0]) {\n        // Create a variant of the first route with adjusted parameters if we don't have enough routes\n        const baseRoute = convertedRoutes[0]\n        const adjustmentFactor = 1 - (i * 0.1) // Slightly adjust scores for variety\n        routes.push({\n          ...baseRoute,\n          id: i + 1,\n          name: routeNames[i],\n          safetyScore: Math.round(baseRoute.safetyScore * adjustmentFactor),\n          crimeScore: Math.round(baseRoute.crimeScore * adjustmentFactor),\n          socialScore: Math.round(baseRoute.socialScore * adjustmentFactor),\n          pedestrianScore: Math.round(baseRoute.pedestrianScore * adjustmentFactor),\n          color: colors[i],\n        })\n      }\n    }\n\n    return {\n      routes,\n      originCoords,\n      destCoords,\n    }\n  } catch (error) {\n    console.error(\"GraphHopper routing error:\", error)\n    return null\n  }\n}\n\n/**\n * Check if GraphHopper API key is configured\n */\nexport function isGraphHopperConfigured(): boolean {\n  return GRAPHHOPPER_API_KEY.length > 0\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}